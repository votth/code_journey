# Lambda function
- Mechanism to set up anonymous function (no name).
- usually used for quick, simple functions.
- Declaration: `[capture_list](parameters)->return_type {};`
	- capture_list: list of the outside, already-declared variables
		- All by reference: [&](params)
		- All by value: [=](params)
	- parameters
	- return_type: optional
``` cpp
// Declare
auto lambda = []() {
	// code_block;
};
// Usage
lambda();
```

---
# Template
- Considered as function blueprints, not really C++ code but rather the code itself will be generated by the complier if a type usage is called in the program.
- Declaration: `template <typename T> T function(T parameters) {};`
	- All 'T' need to be the same data type.
	- Weird behaviour with ptr.
``` cpp
template <typename T> T larger(T a, T b) {
	return (a > b)? a : b;
};
int main(void) {
	double a, b;
	int c, d;
	// this return a double value
	std::cout << larger(a,b) << std::endl;
	// this return an int value
	std::cout << larger(c,d) << std::endl;
}
// template by reference
template <typename T> const T &function(const T &parameters) {};
```
- !! Do not overload template. There's another way/loophole to override template to tell it how to explicitly acts when meets with a predetermined data type.

- Template types:
	- by deduction: let the complier handles itself and chooses the appropriate type
	- by explicit, usage: `function<explicit_type>(params);`

- Template overriding
``` cpp
// Initialize template
template <typename T> T maximum(T a, T b) {};
//Specialization / Override: case to use, with string ptr
template <>
const char *maximum<const char *>(const char *a, const char *b) {};
```

---
# Concept

---
# Class and Struct
- Class vs Struct: only different is class's members are private by default, while Struct's are public

- 'customs types' that are defined by the Dev, consist of:
	- members: variables or ptr only
	- methods: functions to interact with the class, members

- Modifiers:
	- private: only that class and its methods can access
	- protected: only the class and its derived can access
	- public: can be accessed from anywhere

- Constructor and Destructor
	- Special methods, Cons is called when an object of the class is created, while Des is called when the lifetime of an object ends.
		- Cons helps with initializing the objects' members.
		- Des helps with freeing the resources that the object may have accquired during its lifetime, eg ptr.
			- program termination
			- thread exit
			- end of scope, for objs with automatic storage duration and for temporaries whose life was extended by binding to a reference
			- *delete* expression: `delete node;`
			- delete-expression, for obj with dynamic storage
	- Some characteristics only to them:
		- no return type
		- same name as the class
		- Cons can either have params or none, Des doesn't have params
	- Declaration

``` cpp
class Node {
	private:
		int m_data;
		node *m_next_ptr;
	public:
		// Constructors
		node();
		node(int t_data, node *t_next_ptr) {
			this.m_data = t_data;
			this.m_next_ptr = t_next_ptr;
		}
		// Destructor
		// {} can be left empty to be default Des
		~node() {
			std::cout << "Free node" << this << std::endl;
			free(this);
		}
}
int main() {
	Node new_node = new node(1, nullptr);
	delete new_node;
	return 0;
}
```

- Setters and Getters: methods to modify and read members of obj
	- *this* keyword:
		- A hidden ptr of any obj
		- This ptr contains address of the current object, for which the method is being executed.
		- Usage:
			- within Setters and Getters: `this->members = data`
			- avoid conflicting name with the params

- Class across multiple files
	- Creating 2 new files for a class, for example, with Employee
		- employee.h: contains definition/prototype of the class, usually come with header guard, to avoid duplication
``` cpp
#ifndef EMPLOYEE_H
#define EMPLOYEE_H
// class's prototype
#endif
```
		- employee.cpp: contains methods' implementation
``` cpp
```

---
# C++ accross mulitiple files

---
# Concurrent programming
